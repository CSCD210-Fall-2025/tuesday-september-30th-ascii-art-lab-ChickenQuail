<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Section 1.4: Procedural Decomposition * CSCD210 Study Guide</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="description" content="Good methods name the idea behind the code. If you can describe the behaviour in one sentence, extract it and commit that change by itself.">
</head>
<body>
  <div style="max-width: 900px; margin: 0 auto; font-family: Arial, sans-serif; background: #f7f7f7; border: 2px solid #000; padding: 16px;">
    <section style="border: 2px solid #000; background: #e8f8ec; padding: 12px; text-align: center;">
      <h2 style="margin: 0; font-size: 1.6em;"><span style="font-family: monospace;">Section 1.4: Procedural Decomposition</span></h2>
      <p style="margin-top: 6px; font-size: 0.95em; color: #333;"><strong>CSCD210</strong> * Programming Principles I * Fall Quarter 2025</p>
      <p style="margin-top: 8px;">Good methods name the idea behind the code. If you can describe the behaviour in one sentence, extract it and commit that change by itself.</p>
    </section>
<section style="border: 2px solid #000; background: #fff; padding: 14px; margin-top: 16px;">
      <h3 style="margin: 0 0 8px; font-size: 1.2em;"><span style="font-family: monospace;">Bare minimum checklist</span></h3>
      <p style="margin: 0 0 8px;">Focus on how methods help you manage repetition and clarity.</p>
      <ol style="margin: 0 0 12px 20px;">
      <li>Identify at least two chunks of repeated output that deserve their own helper method.</li>
      <li>Trace which method runs next when `main` calls another method and that method calls a helper.</li>
      <li>Refactor one example so each commit introduces a single helper method and keeps the program compiling.</li>
      </ol>
      <p style="margin: 0; font-weight: 600;">Why it matters: Good methods name the idea behind the code. If you can describe the behaviour in one sentence, extract it and commit that change by itself.</p>
    </section>
<section style="border: 2px solid #000; background: #fff7e5; padding: 12px; margin-top: 16px;"><details class="section-toggle" style="margin: 0;"><summary style="cursor: pointer; font-weight: 600; font-size: 1.3em;"><span style="font-family: monospace;">Quick Reference</span></summary><div style="margin-top: 10px;"><details class="nested-toggle" style="margin-top: 8px; border: 1px solid #000; background: #fbfbfb; padding: 8px;"><summary style="cursor: pointer; font-weight: 600;">Summary</summary><div style="margin-top: 6px;"><p> This section introduces <strong>procedural
decomposition</strong>, which is the idea of breaking a program into
smaller pieces (subroutines) to manage complexity. In Java, these pieces
are implemented as <strong>static methods</strong>. We learn how to
define our own static methods to group statements and eliminate
redundancy. Key topics include how to write a static method, how to call
methods, and understanding the <strong>flow of control</strong> when one
method calls another. We see that static methods can call each other to
accomplish tasks, enabling hierarchical decomposition of a problem. An
example is given (like printing repetitive patterns or parts of a
figure) to illustrate how methods improve code structure. We also
encounter a cautionary example of a runtime error (infinite recursion
causing a stack overflow) to emphasize that while methods are powerful,
they must be used correctly. By the end, students should be comfortable
with reading and writing simple static methods and understanding how a
program's execution moves between <code>main</code> and these
methods.</p></div></details><details class="nested-toggle" style="margin-top: 8px; border: 1px solid #000; background: #fbfbfb; padding: 8px;"><summary style="cursor: pointer; font-weight: 600;">Key Concepts and Learning Objectives</summary><div style="margin-top: 6px;"><ul>
<li>Understand the concept of <strong>procedural decomposition</strong>:
solving a big problem by breaking it into smaller, more manageable
sub-problems (methods).</li>
<li>Learn how to <strong>define a static method</strong> in Java: the
syntax (<code>public static void methodName() { ... }</code> for methods
that don't return a value and don't take parameters, as is common early
on) and where to place method definitions (inside a class, but outside
of other methods).</li>
<li>Learn how to <strong>call a method</strong> from another method. For
example, how <code>main</code> can call a static method you've written,
causing the program to jump to that method's code, execute it, then
return.</li>
<li>Recognize situations where using static methods can eliminate
repetitive code and improve readability (e.g., if you have identical or
very similar code in multiple places, put it in a method and call the
method instead).</li>
<li>Understand <strong>flow of control</strong> with method calls: the
order in which statements execute when methods call each other.
Specifically, that a call to a method causes a jump to that method, and
when the method finishes, control returns to the point after where it
was called. We trace an example of method calls step-by-step.</li>
<li>Know that static methods can call other static methods (and
themselves, though recursion should be used carefully).</li>
<li>Be aware of potential pitfalls, like creating an infinite loop or
infinite recursion if a method calls itself without a stopping condition
(illustrating a runtime error as discussed in 1.3).</li>
<li>Develop a habit of identifying logical structure in a problem and
using methods to mirror that structure in code (this also ties into
<strong>top-down design</strong> or stepwise refinement, though those
terms might not be explicitly used yet).</li>
</ul></div></details><details class="nested-toggle" style="margin-top: 8px; border: 1px solid #000; background: #fbfbfb; padding: 8px;"><summary style="cursor: pointer; font-weight: 600;">New Terms (Definitions)</summary><div style="margin-top: 6px;"><div style="display: grid; gap: 8px; margin-top: 8px;"><details class="flashcard" style="border: 1px solid #000; background: #ffffff; padding: 8px;"><summary style="cursor: pointer; font-weight: 600;">Static Method</summary><div style="margin-top: 6px;"> A block of code with a name, which
can be executed (called) from anywhere in the class (or even from other
classes if public). It's "static" meaning it belongs to the class, not
to any object instance. It typically performs a task and then returns
control back to the caller. Syntax example:</div></details><details class="flashcard" style="border: 1px solid #000; background: #ffffff; padding: 8px;"><summary style="cursor: pointer; font-weight: 600;">public</summary><div style="margin-top: 6px;"><p>public static void methodName() { // ... code ... }</p><p>defines a static method named <code>methodName</code> that takes no
parameters and returns nothing (<code>void</code>).</p></div></details><details class="flashcard" style="border: 1px solid #000; background: #ffffff; padding: 8px;"><summary style="cursor: pointer; font-weight: 600;">Method Call</summary><div style="margin-top: 6px;"> The act of invoking/executing a
method's code. You call a method by writing its name followed by
parentheses (and arguments if needed, though for now our methods have no
parameters). Example: <code>methodName();</code> calls the method
defined above. The program will jump to that method, run its statements,
then come back.</div></details><details class="flashcard" style="border: 1px solid #000; background: #ffffff; padding: 8px;"><summary style="cursor: pointer; font-weight: 600;">Procedural Decomposition</summary><div style="margin-top: 6px;"> The process of breaking
down a complex task into simpler sub-tasks (procedures/methods). Each
method handles a specific part of the task. By doing this, you reduce
redundancy and make the program easier to understand and maintain.</div></details><details class="flashcard" style="border: 1px solid #000; background: #ffffff; padding: 8px;"><summary style="cursor: pointer; font-weight: 600;">Flow of Control (Execution Flow)</summary><div style="margin-top: 6px;"> The sequence in
which statements and method calls execute. Normally, code runs line by
line in <code>main</code>, but when a method is called, control
transfers to that method. When that method ends (completes its
statements or hits a return), control goes back to the caller, picking
up right after the call.</div></details><details class="flashcard" style="border: 1px solid #000; background: #ffffff; padding: 8px;"><summary style="cursor: pointer; font-weight: 600;">Top-Down Design</summary><div style="margin-top: 6px;"> (conceptual, even if not
explicitly named) A strategy where you start with the high-level
structure of the program (what major tasks need to happen) and break
those into methods, then further refine the methods as needed. This
often involves writing method stubs and then filling them in.</div></details><details class="flashcard" style="border: 1px solid #000; background: #ffffff; padding: 8px;"><summary style="cursor: pointer; font-weight: 600;">Redundancy</summary><div style="margin-top: 6px;"> In code, redundancy refers to having
the same or very similar code in multiple places. It's usually something
we want to eliminate because it makes code longer and harder to update
(if one part changes, you have to change all the duplicates). Methods
help remove redundancy by allowing code reuse.</div></details><details class="flashcard" style="border: 1px solid #000; background: #ffffff; padding: 8px;"><summary style="cursor: pointer; font-weight: 600;">Modularity</summary><div style="margin-top: 6px;"> The degree to which code is organized
into separate chunks (modules or methods) that have clear purposes.
Writing modular code (with methods) makes it easier to understand and
reuse.</div></details><details class="flashcard" style="border: 1px solid #000; background: #ffffff; padding: 8px;"><summary style="cursor: pointer; font-weight: 600;">Stack Trace</summary><div style="margin-top: 6px;"> (Advanced term, possibly mentioned if
runtime error from recursion is shown) A report of the active method
calls in a program when a runtime error occurs (like the
<code>StackOverflowError</code>). It basically lists which method called
which, down to where the error happened. This helps in debugging deep
call chains. Not a primary focus now, but could be mentioned in context
of infinite recursion example.</div></details><details class="flashcard" style="border: 1px solid #000; background: #ffffff; padding: 8px;"><summary style="cursor: pointer; font-weight: 600;">Return (from a method)</summary><div style="margin-top: 6px;"> When a method finishes
executing (either by reaching the end of its block or encountering a
<code>return</code> statement), control returns to the place where the
method was called. For <code>void</code> methods, we typically don't
write a <code>return</code> unless we want to exit early; it returns
automatically at the end.</div></details><details class="flashcard" style="border: 1px solid #000; background: #ffffff; padding: 8px;"><summary style="cursor: pointer; font-weight: 600;">Hierarchy of Methods</summary><div style="margin-top: 6px;"> Thinking of method structure
in terms of higher-level tasks and sub-tasks. For example, a high-level
method might call two mid-level methods, each of which calls lower-level
methods, etc., forming a tree of calls that corresponds to the problem's
structure.</div></details></div></div></details><details class="nested-toggle" style="margin-top: 8px; border: 1px solid #000; background: #fbfbfb; padding: 8px;"><summary style="cursor: pointer; font-weight: 600;">What You Should Know by the End</summary><div style="margin-top: 6px;"><ul>
<li>How to create static methods to organize your code. For example,
given a task (like print a certain pattern twice), you should be able to
write a method for the pattern and call it twice, instead of writing the
pattern code twice.</li>
<li>The proper syntax and placement for method definitions in a class
(they should be inside the class but not nested inside other
methods).</li>
<li>How to identify portions of code that are candidates for method
extraction (e.g., repetitive code or logically distinct tasks).</li>
<li>That when you call a method, the program's execution "goes to" that
method, runs through it, then comes back. If methods call other methods,
this can nest deeply, but conceptually it's like a trail of tasks that
eventually returns to main.</li>
<li>Tracing simple programs with multiple methods: you should be able to
follow an example of methods calling each other and predict the output
or sequence of actions.</li>
<li>The benefits of using methods: code is more readable (you can give
methods names that describe their purpose), there's less repetition
(write once, call many times), and it's easier to troubleshoot smaller
chunks in isolation.</li>
<li>A caution that methods calling themselves (recursion) should be
approached carefully - without a base condition, it leads to infinite
recursion and a runtime error. (We won't do complex recursion now, but
you've seen how it could go wrong.)</li>
<li>Feel comfortable writing a program that includes multiple static
methods and have <code>main</code> orchestrate the calls to these
methods to accomplish the overall task.</li>
</ul></div></details><details class="nested-toggle" style="margin-top: 8px; border: 1px solid #000; background: #fbfbfb; padding: 8px;"><summary style="cursor: pointer; font-weight: 600;">Self-Check Questions (Toggle to reveal answers)</summary><div style="margin-top: 6px;"><ul>
<li><p><strong>Q: What is one reason to use static methods in your
program?</strong><br/></p><details><summary><strong>Show
Answer</strong></summary> <p>One key reason is to
eliminate redundancy. If you find yourself writing very similar code in
multiple places, you can put that code into a static method and simply
call the method whenever you need it. Methods also make programs easier
to read by giving a name to a group of statements (clarifying their
purpose). Overall, static methods help organize code into logical
sub-tasks, making the program more modular and maintainable.</p>
</details></li>
<li><p><strong>Q: True or False - "A static method can only be called
once in a program."</strong><br/></p><details><summary><strong>Show
Answer</strong></summary> <p>False. You can call a
static method as many times as needed (or not at all) after it's
defined. Each call will execute the method's code. In fact, reusability
is a major benefit of methods - you write the code once, and then call
it whenever required, possibly multiple times even from different
places.</p> </details></li>
<li><p><strong>Q: When a method</strong><code>A</code><strong>calls
another method</strong><code>B</code><strong>, what happens after
method</strong><code>B</code><strong>finishes
executing?</strong><br/></p><details><summary><strong>Show
Answer</strong></summary> <p>After method B finishes
(either it runs to the end of its code or hits a return statement),
control returns back to method A, precisely to the point right after
where method B was called. Method A then continues execution from that
point onward. (In other words, the program "remembers" where to come
back in method A after completing method B.)</p>
</details></li>
</ul></div></details></div></details></section>
<section style="border: 2px solid #000; background: #e8efff; padding: 12px; margin-top: 16px;"><details class="section-toggle" style="margin: 0;"><summary style="cursor: pointer; font-weight: 600; font-size: 1.3em;"><span style="font-family: monospace;">Tutorial and Code-Along</span></summary><div style="margin-top: 10px;"><p>So far, all our programs have consisted of a single <code>main</code>
method with a sequence of <code>println</code> statements. As you saw
with <code>DrawFigures1</code>, this can lead to a lot of repetitive
code. Imagine if a program needed to print that complex figure multiple
times or with slight variations - maintaining such code would be
painful. Enter <strong>procedural decomposition</strong>: the art of
dividing a program's tasks into subtasks, each handled by a method.</p><p>Think of procedural decomposition as organizing a big task like
organizing a team project: rather than one person doing everything, you
assign subtasks to team members, then combine results. In coding, we'll
assign subtasks to methods.</p><details class="nested-toggle" style="margin-top: 8px; border: 1px solid #000; background: #fbfbfb; padding: 8px;"><summary style="cursor: pointer; font-weight: 600;">1. Defining Static Methods</summary><div style="margin-top: 6px;"><p><br/>
A <strong>static method</strong> in Java is like a mini-program inside
your program. You give it a name and define the steps (statements) it
should perform. Later, you can "call" that name to execute those
steps.</p><p>Let's start with a simple scenario: Suppose we want to print a
message like:</p><pre><code>Welcome!
This program performs several tasks.
Enjoy!</code></pre><p>And we want to show this welcome message at multiple points in our
program (say at the start and after certain operations as a kind of
header). Without methods, you'd have to write those three lines each
time you want the welcome message. With a method, you write it once:</p><pre><code>public class WelcomeProgram {
    // Define a static method that prints the welcome message
    public static void printWelcomeMessage() {
        System.out.println("Welcome!");
        System.out.println("This program performs several tasks.");
        System.out.println("Enjoy!");
    }

    public static void main(String[] args) {
        // Call the welcome message method twice
        printWelcomeMessage();
        System.out.println("...(some other program logic here)...");
        printWelcomeMessage();
    }
}</code></pre><p>In this example: - We defined a method named
<code>printWelcomeMessage</code>. It's <code>public static void</code>
which means anyone can call it (<code>public</code>), it belongs to the
class (<code>static</code>), and it doesn't return any value
(<code>void</code>). Inside the parentheses <code>()</code>, we didn't
specify any parameters - this method needs no outside information to do
its job. - The method's body is between <code>{ }</code>. It simply
prints three lines. These could be any statements - methods can contain
calculations, loops, etc., but we're sticking to simple prints for now.
- In <code>main</code>, we use <code>printWelcomeMessage();</code> just
like it's a built-in command. That line will jump to execute the
method's body, then return. - We call it twice to illustrate reuse - the
welcome message will print, then we print some other line, then the
welcome message prints again.</p><p>If you run this program, the output will be:</p><pre><code>Welcome!
This program performs several tasks.
Enjoy!
...(some other program logic here)...
Welcome!
This program performs several tasks.
Enjoy!</code></pre><p>You see the welcome message appears twice, as intended, without
duplicating the code in our source - we just called the method
twice.</p></div></details><details class="nested-toggle" style="margin-top: 8px; border: 1px solid #000; background: #fbfbfb; padding: 8px;"><summary style="cursor: pointer; font-weight: 600;">Where to define methods</summary><div style="margin-top: 6px;"><p> You define static methods
inside the class, but not inside <code>main</code> or any other method.
Notice in the code above, <code>printWelcomeMessage</code> is defined
outside of <code>main</code> (but still within the
<code>WelcomeProgram</code> class). Java does not allow you to define
one method inside another; methods are peers within a class.</p></div></details><details class="nested-toggle" style="margin-top: 8px; border: 1px solid #000; background: #fbfbfb; padding: 8px;"><summary style="cursor: pointer; font-weight: 600;">2. Using Static Methods to Eliminate
Redundancy</summary><div style="margin-top: 6px;"><p><br/>
Let's revisit <code>DrawFigures1</code>. We identified a lot of repeated
patterns in that figure printing. Without diving back into all that
code, conceptually, what were the repeating parts? - The triangular
"cone" shape (the <code>/\</code> with increasing spaces) appears
multiple times. - The inverted "V" shape (<code>\/</code> with spaces
above it) appears multiple times. - The rectangular box (the
<code>+------+</code> and <code>| |</code> lines) appears multiple
times. - The lines with "United" and "States" appear once in the middle,
so those might stay in one place.</p><p>If we were to decompose that, we could imagine methods like: -
<code>drawCone()</code> - prints the triangle shape. -
<code>drawInvertedCone()</code> or maybe call it <code>drawV()</code> -
prints the inverted shape. - <code>drawBox()</code> - prints the box
with empty interior. - Then methods for the big parts: -
<code>drawDiamond()</code> that prints a cone and inverted cone (forming
an hourglass shape). - <code>drawX()</code> that prints an inverted cone
then a cone (forming an X shape). - <code>drawRocket()</code> that
prints a cone, a box, the "United States" text, another box, and another
cone.</p><p>This breakdown matches how the authors of our textbook proceed in the
case study (as we'll see in Section 1.5). But in this section, the key
is understanding the concept of breaking it down.</p></div></details><details class="nested-toggle" style="margin-top: 8px; border: 1px solid #000; background: #fbfbfb; padding: 8px;"><summary style="cursor: pointer; font-weight: 600;">A simpler example of redundancy elimination</summary><div style="margin-top: 6px;"><p><br/>
Suppose we want to print a simple pattern, say two identical rows of
stars:</p><pre><code>*****
*****</code></pre><p>Without methods:</p><pre><code>System.out.println("*****");
System.out.println("*****");</code></pre><p>This is fine for two lines, but imagine it was 10 identical lines.
You'd copy-paste, which is not ideal. Instead, we can do:</p><pre><code>public static void printLineOfStars() {
    System.out.println("*****");
}
...
printLineOfStars();
printLineOfStars();</code></pre><p>Now we have one method that prints a line of stars. We just call it
twice to get two lines. If we needed 10 lines, we could call it in a
loop or call it 10 times (loops are a Chapter 2 topic, so for now maybe
we'd call it multiple times, though that's still repetitive to write -
but better structured than the raw output).</p></div></details><details class="nested-toggle" style="margin-top: 8px; border: 1px solid #000; background: #fbfbfb; padding: 8px;"><summary style="cursor: pointer; font-weight: 600;">3. Static Method Mechanics - Flow of Control</summary><div style="margin-top: 6px;"><p><br/>
It's crucial to understand how a program flows when methods are
involved. Let's trace a scenario step by step. Consider:</p><pre><code>public class FlowDemo {
    public static void main(String[] args) {
        System.out.println("A");
        firstMethod();
        System.out.println("B");
    }
    public static void firstMethod() {
        System.out.println("C");
        secondMethod();
        System.out.println("D");
    }
    public static void secondMethod() {
        System.out.println("E");
    }
}</code></pre><p>What is the output order? Let's trace: - The program starts in
<code>main</code>. - It prints "A" (so output so far: <code>A</code>). -
Then it calls <code>firstMethod();</code>. At this point, Java pauses
execution of <code>main</code> at that spot and jumps to execute
<code>firstMethod</code>. - Inside <code>firstMethod</code>, it prints
"C" (output: <code>A C</code> on separate lines). - Then
<code>firstMethod</code> calls <code>secondMethod();</code>. So now
<code>firstMethod</code> is paused at that point, and execution jumps to
<code>secondMethod</code>. - Inside <code>secondMethod</code>, it prints
"E" (output now: <code>A C E</code> each on their own lines). -
<code>secondMethod</code> finishes (reaches its end). Control returns to
the point in <code>firstMethod</code> right after where
<code>secondMethod()</code> was called. - <code>firstMethod</code>
resumes and prints "D" (output: <code>A C E D</code>). -
<code>firstMethod</code> finishes. Control returns to <code>main</code>
after the <code>firstMethod();</code> call. - <code>main</code> resumes
and prints "B" (output: <code>A C E D B</code> in sequence, each letter
likely on its own line as we used println).</p><p>So the actual output lines will be:</p><pre><code>A
C
E
D
B</code></pre><p>This example shows how the execution jumps in and out of methods like
a nested workflow. A helpful analogy: think of each method call as a
"detour" or subtask. <code>main</code> had a task (print A, do
something, print B). The "do something" was delegated to
<code>firstMethod</code>. <code>firstMethod</code> in turn delegated
part of its work to <code>secondMethod</code>. Once
<code>secondMethod</code> was done, <code>firstMethod</code> could
finish its part, then <code>main</code> could finish.</p><p>This is exactly how larger programs operate. By breaking tasks into
methods, you can reason about each piece separately. For instance, you
know <code>secondMethod</code> prints E and that's it. If there's an
error in printing E, you know it's confined to
<code>secondMethod</code>.</p></div></details><details class="nested-toggle" style="margin-top: 8px; border: 1px solid #000; background: #fbfbfb; padding: 8px;"><summary style="cursor: pointer; font-weight: 600;">4. Writing Static Methods that Call Other
Methods</summary><div style="margin-top: 6px;"><p><br/>
You can have methods call methods call methods, as we saw. This is often
how a complex task is structured: - A high-level method outlines the big
steps, calling sub-methods for each step. - Those sub-methods might call
sub-sub-methods for more detailed tasks.</p><p>For an everyday example, think of a method <code>makeDinner()</code>.
It might call <code>cookRice()</code>, <code>stirFryVeggies()</code>,
and <code>grillChicken()</code>. Each of those could potentially call
even more specific methods like <code>washRice()</code>,
<code>boilWater()</code>, etc. The idea is each method has a clear
responsibility.</p><p>In programming assignments, you might be instructed to write methods
like <code>computeSomething</code>, <code>printHeader</code>,
<code>printFooter</code>, etc. These help break the problem up.</p></div></details><details class="nested-toggle" style="margin-top: 8px; border: 1px solid #000; background: #fbfbfb; padding: 8px;"><summary style="cursor: pointer; font-weight: 600;">Now You Try - Create and Use Static Methods</summary><div style="margin-top: 6px;"><p><br/>
Let's do a hands-on exercise: - Write a program that prints a simple
shape or pattern, but structure it with methods. - For example, print a
small text art of a face composed of multiple parts:</p><pre><code>+-----+
| o o |
|  ^  |
| '_' |
+-----+</code></pre><p>This has a top border, some face features lines, and a bottom border.
We can identify pieces: - A method to print the border
(<code>+-----+</code>). - A method to print the eyes line
(<code>| o o |</code>). - A method to print the nose line
(<code>| ^ |</code>). - A method to print the mouth line
(<code>| '_' |</code>).</p><p>Now plan: We'll have <code>printBorder()</code>,
<code>printEyes()</code>, <code>printNose()</code>,
<code>printMouth()</code>. Then <code>main</code> (or a method
<code>printFace()</code>) will call them in order.</p><p>Try coding this:</p><pre><code>public class FaceArt {
    public static void printBorder() {
        System.out.println("+-----+");
    }
    public static void printEyes() {
        System.out.println("| o o |");
    }
    public static void printNose() {
        System.out.println("|  ^  |");
    }
    public static void printMouth() {
        System.out.println("| '_' |");
    }

    public static void main(String[] args) {
        printBorder();
        printEyes();
        printNose();
        printMouth();
        printBorder();
    }
}</code></pre><p>Running this would output the face:</p><pre><code>+-----+
| o o |
|  ^  |
| '_' |
+-----+</code></pre><p>Notice we called <code>printBorder()</code> twice (top and bottom).
Without methods, we would have had to write that line twice. With
methods, we wrote it once and reused it. The benefit is even more
apparent if, say, we wanted to change the border width - we'd change the
string in <code>printBorder</code> method once, instead of in multiple
places.</p><p>This approach also makes the code self-documenting.
<code>printEyes()</code> clearly prints the eyes line. If someone else
reads the <code>main</code>, they see the high-level structure:</p><pre><code>border, eyes, nose, mouth, border</code></pre><p>and can guess we're drawing a face, even without comments.</p></div></details><details class="nested-toggle" style="margin-top: 8px; border: 1px solid #000; background: #fbfbfb; padding: 8px;"><summary style="cursor: pointer; font-weight: 600;">5. Avoiding Redundant and Trivial Methods</summary><div style="margin-top: 6px;"><p><br/>
While methods are great, a quick note: not everything needs to be a
separate method. If something is done only once and is very short,
making a method for it might be overkill. For instance, if your program
prints "Game Over" once at the end, you probably don't need a
<code>printGameOver()</code> method - you can just print it in
<code>main</code>. Use methods where they add clarity or avoid
repetition.</p><p>Also, don't create methods for every single line by rote. Group
logically related lines. For example, if drawing a face, grouping all
features in separate methods is fine, or grouping some lines if they
always appear together could also make sense (maybe
<code>printFeatures()</code> could print all three face lines, and
border separately). There's some design choice here. The goal is clarity
and reuse.</p></div></details><details class="nested-toggle" style="margin-top: 8px; border: 1px solid #000; background: #fbfbfb; padding: 8px;"><summary style="cursor: pointer; font-weight: 600;">6. A Cautionary Example: Infinite Recursion (Runtime Error
Revisited)</summary><div style="margin-top: 6px;"><p><br/>
Let's revisit that recursion example to tie it into what we know now. In
Section 1.3, we showed a method calling itself with no end. That's a
method use case too (called <strong>recursion</strong> when a method
calls itself). Recursion can be useful, but you must have a condition
that stops the recursive calls, otherwise it's an infinite loop of
calls.</p><p>Our example <code>oops()</code> method had no stop, causing a stack
overflow. The takeaway for now: if you ever accidentally write something
like:</p><pre><code>public static void hello() {
    System.out.println("Hello");
    hello();  // calls itself again
}</code></pre><p>and call <code>hello()</code>, you'll get an infinite recursion
(unless you have some conditional logic to stop after some point, which
we haven't covered yet).</p><p>This relates to procedural decomposition in that methods can call
other methods (including themselves), but you must ensure that this
chain of calls eventually terminates.</p><p>In practice, infinite recursion or infinite loops are logic errors
that can be tough to debug because the program doesn't show output
indicating where it got stuck (except maybe a long dump of a stack trace
in recursion). So just be mindful: any method call chain should
naturally come to an end.</p></div></details><details class="nested-toggle" style="margin-top: 8px; border: 1px solid #000; background: #fbfbfb; padding: 8px;"><summary style="cursor: pointer; font-weight: 600;">7. Building Programs with Multiple Methods - A Complete
Example</summary><div style="margin-top: 6px;"><p><br/>
Let's do one more concrete example that's slightly more interesting:
printing a short song or rhyme with repeated chorus.</p><p>Suppose we want to print the lyrics of "Twinkle, Twinkle, Little
Star" (just as an example of structure):</p><pre><code>Twinkle, twinkle, little star,
How I wonder what you are!

Twinkle, twinkle, little star,
How I wonder what you are!
Up above the world so high,
Like a diamond in the sky.

Twinkle, twinkle, little star,
How I wonder what you are!</code></pre><p>We notice "Twinkle, twinkle, little star,\nHow I wonder what you
are!" is a refrain that repeats three times (beginning, middle, end).
The middle part has extra lines in between.</p><p>We can method-ize this: - <code>printRefrain()</code> prints the two
lines:</p><pre><code>Twinkle, twinkle, little star,
How I wonder what you are!</code></pre><p>- <code>printMiddleVerse()</code> prints:</p><pre><code>Up above the world so high,
Like a diamond in the sky.</code></pre><p>- Then our main (or maybe <code>printSong</code>) could do:</p><pre><code>printRefrain();
System.out.println(); // blank line
printRefrain();
printMiddleVerse();
System.out.println();
printRefrain();</code></pre><p>(This is a design choice; you might structure differently but this
illustrates one way.)</p><p>The key is, by identifying the repeating part (refrain), we made a
method. If the lyrics changed, we'd change it in one place. And the
structure of the song is clear in main.</p></div></details><details class="nested-toggle" style="margin-top: 8px; border: 1px solid #000; background: #fbfbfb; padding: 8px;"><summary style="cursor: pointer; font-weight: 600;">Now You Try - Identify Method Candidates in a
Task</summary><div style="margin-top: 6px;"><p><br/>
Think about a simple task, like outputting a calendar for a month that
has weeks. Each week might be a row of days. How could you use methods?
Perhaps a <code>printWeek()</code> that prints Monday through Sunday
dates. Or if making a pattern like a checkerboard, a method for printing
a row.</p><p>Identifying patterns and grouping them into methods will become
second nature with practice. For now, a good rule of thumb: - If you
have copy-pasted code - definitely a candidate for a method. - If you
can describe a section of code in one simple sentence (e.g., "print the
border and empty line interior of a box"), that section could be a
method doing exactly that, named accordingly (<code>printBoxFrame</code>
maybe). - If <code>main</code> is getting long or doing many steps,
consider splitting some steps into methods. Each method can make
<code>main</code> read more like a table of contents of what the program
does.</p></div></details><details class="nested-toggle" style="margin-top: 8px; border: 1px solid #000; background: #fbfbfb; padding: 8px;"><summary style="cursor: pointer; font-weight: 600;">Summary of Section 1.4</summary><div style="margin-top: 6px;"><p><br/>
We introduced the power of static methods. They allow us to control
program complexity by dividing tasks and reusing code. You learned how
to declare methods and call them, and traced how the execution flows
through method calls. By practicing writing your own methods and
restructuring code to use them, you're preparing for writing larger
programs in a manageable way.</p><p>Coming up in Section 1.5, we'll apply what we learned here to the big
<code>DrawFigures</code> case study, showing how that complex ASCII art
example is greatly simplified by using methods for each part. We'll also
carefully walk through the execution of the final program to solidify
understanding of flow of control. Keep thinking about code in terms of
structure: you're not just writing lines, you're building components
that fit together to solve a problem.</p></div></details></div></details></section>
    <section style="border: 2px dashed #000; background: #fff; padding: 12px; margin-top: 16px;">
      <p style="margin: 0; font-weight: 600;">Help us improve:</p>
      <p style="margin: 4px 0 0;">Let us know what was confusing or where you got stuck. <a href="feedback.html" style="color: #184592; font-weight: 600;">Share anonymous feedback</a>.</p>
    </section>
    <div style="margin-top: 16px; text-align: center;">
      <a href="index.html" style="color: #184592; font-weight: 600;">Back to Chapter 1 Overview</a>
    </div>
  </div>
</body>
</html>